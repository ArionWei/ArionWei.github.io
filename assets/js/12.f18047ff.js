(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{184:function(v,t,e){"use strict";e.r(t);var s=e(3),o=Object(s.a)({},(function(){var v=this,t=v.$createElement,e=v._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"v-show-与-v-if-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-show-与-v-if-的区别"}},[v._v("#")]),v._v(" v-show 与 v-if 的区别")]),v._v(" "),e("p",[e("code",[v._v("v-if")]),v._v(" 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。")]),v._v(" "),e("p",[e("code",[v._v("v-show")]),v._v(" 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 "),e("code",[v._v("display")]),v._v(" 属性进行切换。")]),v._v(" "),e("p",[v._v("所以，"),e("code",[v._v("v-if")]),v._v(" 适用于在运行时很少改变条件，不需要频繁切换条件的场景；"),e("code",[v._v("v-show")]),v._v(" 则适用于需要非常频繁切换条件的场景。")])])}),[],!1,null,null,null);t.default=o.exports}}]);